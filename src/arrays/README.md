## Task #5
*Advanced Array Filtering*
1. Create a function called `customFilterUnique` that takes an array and a callback function as arguments. The `customFilterUnique` function should filter the array using the callback function to determine uniqueness. The resulting array should contain only unique elements based on the callback's logic.
2. Use the `customFilterUnique` function to filter an array of objects based on a specific property and return only unique objects.

*Array Chunking*
1. Create a function called `chunkArray` that takes an array and a chunk size as arguments. The `chunkArray` function should divide the array into smaller arrays, each containing elements of the specified chunk size. The function should return an array of arrays.
2. Optimize the `chunkArray` function to minimize memory usage while chunking the array.

*Array Shuffling*
1. Create a function called `customShuffle` that takes an array as an argument and returns a new array with its elements randomly shuffled.
2. Implement the `customShuffle` function using an efficient shuffling algorithm to achieve uniform randomness.

*Array Intersection and Union*
1. Create a function called `getArrayIntersection` that takes two arrays as arguments and returns a new array containing the common elements between the two arrays.
2. Create a function called `getArrayUnion` that takes two arrays as arguments and returns a new array containing all unique elements from both arrays, without any duplicates.

*Array Performance Analysis*
1. Implement a function called `measureArrayPerformance` that takes a function and an array as arguments. The `measureArrayPerformance` function should execute the provided function with the given array as input and measure the execution time.
2. Use the `measureArrayPerformance` function to compare the performance of built-in array methods (`map`, `filter`, `reduce`, etc.) against your custom array manipulation functions.
